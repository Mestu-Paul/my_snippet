{
	"Merge sort tree":{
		"prefix": "Merge sort tree",
		"body": [
			"class Merge_Sort_Tree{",
			"    public:",
			"    vi v;",
			"    vvi tree;",
			"    int n;",
			"    Merge_Sort_Tree(int _n){",
			"        n=_n;",
			"        v.resize(n+1);",
			"        tree.resize(4*n);",
			"    }",
			"    void Merge(int nd){",
			"        int l = nd*2,r=nd*2+1;",
			"        int n1 = siz(tree[nd*2]);",
			"        int n2 = siz(tree[nd*2+1]);",
			"        int i=0,j=0;",
			"        while(i<n1&&j<n2){",
			"            if(tree[l][i]<tree[r][j]){",
			"                tree[nd].pb(tree[l][i++]);",
			"            }",
			"            else{",
			"                tree[nd].pb(tree[r][j++]);",
			"            }",
			"        }",
			"        while(i<n1)tree[nd].pb(tree[l][i++]);",
			"        while(j<n2)tree[nd].pb(tree[r][j++]);",
			"    }",
			"    void build(int nd, int b, int e){",
			"        if(b>e)return;",
			"        if(b==e){",
			"            tree[nd].pb(v[b]);",
			"            return ;",
			"        }",
			"        int m = (b+e)/2;",
			"        build(nd*2,b,m);",
			"        build(nd*2+1,m+1,e);",
			"        Merge(nd);",
			"    }",
			"    int query(int nd, int b, int e, int l, int r, int k){",
			"        if(b>r||e<l)return 0;",
			"        if(l<=b&&e<=r){",
			"            int pos = upper_bound(all(tree[nd]),k)-tree[nd].begin();",
			"            return siz(tree[nd])-pos;",
			"        }",
			"        int m=(b+e)/2;",
			"        int p1 = query(nd*2,b,m,l,r,k);",
			"        int p2 = query(nd*2+1,m+1,e,l,r,k);",
			"        return p1+p2;",
			"    }",
			"};",
		],
		"description": "implemented class merge sort tree",
	}
}