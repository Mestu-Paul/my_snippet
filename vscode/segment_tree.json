{
	"SegmentTree":{
		"prefix": "segTree",
		"body": [
			"#define lft nd*2",
			"#define rgt nd*2+1",
			"#define mid (b+e)/2",
			"class segtree{",
			"    public:",
			"    int n;",
			"    vector<int> tree,v;",
			"    segtree(int _n, vi& a){",
			"        n=_n;",
			"		 v.resize(n+1);",
			"		 for(int i=1; i<=n; i++)v[i]=a[i];",
			"        tree.resize(n*4);",
			"    }",
			"	void build(int nd, int b, int e){",
			"		if(b>e)return;",
			"		if(b==e){",
			"			tree[nd]=v[b];",
			"			return;",
			"		}",
			"		build(lft,b,mid);",
			"		build(rgt,mid+1,e);",
			"		tree[nd]=max(tree[lft],tree[rgt]);",
			"	}",
			"    void update(int nd, int b, int e, int l){",
			"        if(b>e or e<l or l<b)return;",
			"        if(b==e and l==b){",
			"            tree[nd]++;",
			"            return;",
			"        }",
			"        update(lft,b,mid,l);",
			"        update(rgt,mid+1,e,l);",
			"        tree[nd]=tree[lft]+tree[rgt];",
			"    }",
			"    int query(int nd, int b, int e, int l, int r){",
			"        if(b>e or e<l or r<b)return 0;",
			"        if(l<=b and e<=r){",
			"            return tree[nd];",
			"        }",
			"        int p1 = query(lft,b,mid,l,r);",
			"        int p2 = query(rgt,mid+1,e,l,r);",
			"        return p1+p2;",
			"    }",
			"};",
		],
		"description": "basic seg tree implement",
	}
}